name: Check for New Translatable Strings
on:
  push:
    branches: [master]
    paths:
      - 'app/**/*.cpp'
      - 'app/**/*.hpp'
      - 'app/**/*.h'
  workflow_dispatch:
permissions:
  contents: read
  discussions: write
jobs:
  check-strings:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      - name: Install gettext
        run: sudo apt-get update && sudo apt-get install -y gettext
      - name: Generate fresh POT file
        run: |
          find app -name '*.cpp' -o -name '*.hpp' -o -name '*.h' | sort > /tmp/source_files.txt
          xgettext \
            --files-from=/tmp/source_files.txt \
            --keyword=_ \
            --keyword=wxPLURAL:1,2 \
            --keyword=wxTRANSLATE \
            --language=C++ \
            --from-code=UTF-8 \
            --add-comments=TRANSLATORS \
            --add-location=file \
            --package-name=paperback \
            --output=/tmp/paperback_new.pot
      - name: Compare strings
        id: compare
        run: |
          # Extract full msgid strings (including multi-line) from POT files
          # This awk script properly handles multi-line msgid entries
          extract_msgids() {
            awk '
              /^msgid "/ {
                # Start capturing a new msgid
                in_msgid = 1
                msgid = $0
                # Remove the "msgid " prefix
                sub(/^msgid /, "", msgid)
                next
              }
              in_msgid && /^"/ {
                # Continuation of multi-line msgid
                msgid = msgid $0
                next
              }
              in_msgid && /^msgstr/ {
                # End of msgid, print it (skip empty header msgid)
                in_msgid = 0
                if (msgid != "\"\"") {
                  print msgid
                }
              }
            ' "$1" | sort
          }

          extract_msgids po/paperback.pot > /tmp/old_strings.txt
          extract_msgids /tmp/paperback_new.pot > /tmp/new_strings.txt

          # Find added and removed strings
          comm -13 /tmp/old_strings.txt /tmp/new_strings.txt > /tmp/added.txt
          comm -23 /tmp/old_strings.txt /tmp/new_strings.txt > /tmp/removed.txt

          # Count changes (trim whitespace from wc output)
          ADDED_COUNT=$(wc -l < /tmp/added.txt | tr -d ' ')
          REMOVED_COUNT=$(wc -l < /tmp/removed.txt | tr -d ' ')

          echo "added_count=$ADDED_COUNT" >> $GITHUB_OUTPUT
          echo "removed_count=$REMOVED_COUNT" >> $GITHUB_OUTPUT

          # Only set has_changes if there are actual changes
          if [ "$ADDED_COUNT" -gt 0 ] || [ "$REMOVED_COUNT" -gt 0 ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Found $ADDED_COUNT added and $REMOVED_COUNT removed strings"
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "No translatable string changes detected"
          fi

          # Build the discussion body to a temp file first
          {
            echo "## Translatable Strings Update"
            echo ""
            echo "A recent commit has changed the translatable strings in Paperback."
            echo ""
            echo "**$ADDED_COUNT** string(s) added, **$REMOVED_COUNT** string(s) removed."
            echo ""
            if [ "$ADDED_COUNT" -gt 0 ]; then
              echo "### New strings:"
              echo ""
              echo '```'
              cat /tmp/added.txt
              echo '```'
              echo ""
            fi
            if [ "$REMOVED_COUNT" -gt 0 ]; then
              echo "### Removed strings:"
              echo ""
              echo '```'
              cat /tmp/removed.txt
              echo '```'
              echo ""
            fi
            echo "---"
            echo '**Translators:** Please update your `.po` files using `msgmerge`.'
            echo "See the [translation guide](https://paperback.dev/translations) for instructions."
            echo ""
            echo "Commit: ${{ github.sha }}"
          } > /tmp/body.md

          # Use a random delimiter to avoid conflicts with file content
          DELIMITER="BODY_$(openssl rand -hex 8)"
          {
            echo "body<<$DELIMITER"
            cat /tmp/body.md
            echo "$DELIMITER"
          } >> $GITHUB_OUTPUT
      - name: Close previous translation discussions
        if: steps.compare.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Searching for previous translation discussions to close..."

          # Find all open discussions with "New translatable strings" in the title
          DISCUSSIONS=$(gh api graphql -f query='
            query($owner: String!, $name: String!) {
              repository(owner: $owner, name: $name) {
                discussions(first: 50, states: OPEN) {
                  nodes {
                    id
                    title
                    number
                  }
                }
              }
            }
          ' -f owner="${{ github.repository_owner }}" -f name="${{ github.event.repository.name }}")

          # Extract discussion IDs that match our title pattern
          echo "$DISCUSSIONS" | jq -r '.data.repository.discussions.nodes[] | select(.title | startswith("New translatable strings")) | .id' | while read -r DISC_ID; do
            if [ -n "$DISC_ID" ]; then
              echo "Closing discussion: $DISC_ID"
              gh api graphql -f query='
                mutation($id: ID!) {
                  closeDiscussion(input: {discussionId: $id, reason: OUTDATED}) {
                    discussion { id }
                  }
                }
              ' -f id="$DISC_ID" || echo "Warning: Failed to close discussion $DISC_ID"
            fi
          done

          echo "Finished closing previous discussions"
      - name: Create Discussion
        if: steps.compare.outputs.has_changes == 'true'
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          REPO_DATA=$(gh api graphql -f query='
            query($owner: String!, $name: String!) {
              repository(owner: $owner, name: $name) {
                id
                discussionCategories(first: 10) {
                  nodes { id name }
                }
              }
            }
          ' -f owner="${{ github.repository_owner }}" -f name="${{ github.event.repository.name }}")
          REPO_ID=$(echo "$REPO_DATA" | jq -r '.data.repository.id')
          CATEGORY_ID=$(echo "$REPO_DATA" | jq -r '.data.repository.discussionCategories.nodes[] | select(.name=="Announcements") | .id')

          RESULT=$(gh api graphql -f query='
            mutation($repositoryId: ID!, $categoryId: ID!, $title: String!, $body: String!) {
              createDiscussion(input: {repositoryId: $repositoryId, categoryId: $categoryId, title: $title, body: $body}) {
                discussion { url }
              }
            }
          ' \
            -f repositoryId="$REPO_ID" \
            -f categoryId="$CATEGORY_ID" \
            -f title="New translatable strings - $(date +%Y-%m-%d)" \
            -f body="${{ steps.compare.outputs.body }}")

          echo "Created new discussion:"
          echo "$RESULT" | jq -r '.data.createDiscussion.discussion.url'
